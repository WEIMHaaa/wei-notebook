### 一、索引基数
基数是数据列所包含的不同值的数量。  
例如，某个数据列包含值1、3、7、4、7、3，那么它的基数就是4。索引的基数相对于数据表行数较高（也就是说，列中包含很多不同的值，重复的值很少）的时候，它的工作效果最好。如果某数据列含有很多不同的年龄，索引会很快地分辨数据行。如果某个数据列用于记录性别（只有"M"和"F"两种值），那么索引的用处就不大。如果值出现的几率几乎相等，那么无论搜索哪个值都可能得到一半的数据行。在这些情况下，最好根本不要使用索引，因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。惯用的百分比界线是"30%"。


### 二、索引的建立
1. 根据业务经常查询的语句建立索引；
2. 尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)，表示字段不重复的比率，比率越大扫描的记录数就越少；
3. 如果业务中唯一特性最好建立唯一键，一方面可以保证数据的正确性，另一方面索引的效率能大大提高；


### 三、索引的分类
索引分类：1、普通索引  2、唯一索引  3、主键索引  4、组合索引  5、联合索引
#### 1、普通索引
创建索引：create index 索引的名字 on 表名(列名)   eg. create index empnoIndex on emp_copy(empno)  
删除索引：drop index 索引的名字 on 表名   eg. drop index empnoIndex on emp_copy  
查看索引：show index from 表名  eg. show index from emp_copy  
修改索引：
先删除 ALTER TABLE table_name DROP INDEX index_name     
再以修改后的内容创建同名索引  CREATE INDEX index_name ON table_name
 
#### 2、唯一索引
唯一索引有两个功能：加速查找和唯一约束（可含null）
创建索引：create unique index 索引名 on 表名(列名)  
删除索引：drop index 索引的名字 on 表名  eg. drop index empnoIndex on emp_copy

#### 3、主键索引
主键索引有两个功能：加速查找和唯一约束（不含null）  
主键索引：alter table 表名 add primary key(列名);  eg.alter table emp_copy add primary key(deptno)  
删除主键索引：alter table 表名 drop primary key;   alter table 表名 modify 列名 int, drop primary key;

#### 4、组合索引
组合索引是将n个列组合成一个索引,其应用场景为：频繁的同时使用n列来进行查询，如：where name = 'alex' and email = 'alex@qq.com'。
create index 索引名 on 表名(列名1,列名2)   eg. create index enameIndex on emp_copy(ename,mgr)

#### 5、联合索引
首先介绍一下联合索引（复合索引）。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：  
第一个字段一定是有序的，当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的；
其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。


### 四、索引的优缺点
索引就是一个数据结构，我们把表中的记录用一个适合高效查找的数据结构来表示，目的就是让查询变得更高效。
#### 1、优点
创建唯一性索引，保证数据库表中每一行数据的唯一性；    
加速表和表之间的连接；  
#### 2、缺点
索引需要占物理空间；  
当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度；  
增加了插入和删除的操作时间，一个表拥有的索引越多，插入和删除的速度越慢。如要求快速录入的系统不宜建过多索引；


### 五、适合和不适合加索引的字段
数据库建立索引常用的规则如下：
1. 表的主键. 外键必须有索引；
2. 数据量超过300的表应该有索引；
3. 经常与其他表进行连接的表，在连接字段上应该建立索引；
4. 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5. 索引应该建在选择性高的字段上；
6. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7. 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
   A、正确选择复合索引中的主列字段，一般是选择性较好的字段；  
   B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；  
   C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；  
   D、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；  
8. 频繁进行数据操作的表，不要建立太多的索引；
9. 删除无用的索引，避免对执行计划造成负面影响；


### 六、索引失效原因
1. 对索引列运算，运算包括（+、-、*、/. ！、<>、%、like'%_'（%放在前面）；
2. 类型错误，如字段类型为varchar，where条件用number；
3. 对索引应用内部函数，这种情况下应该建立基于函数的索引如select * from template t where ROUND(t.logicdb_id) = 1此时应该建ROUND(t.logicdb_id)为索引，mysql8.0开始支持函数索引，5.7可以通过虚拟列的方式来支持，之前只能新建一个ROUND(t.logicdb_id)列然后去维护；
4. 如果条件有or，即使其中有条件带索引也不会使用（这也是为什么建议少使用or的原因），如果想使用or，又想索引有效，只能将or条件中的每个列加上索引；
5. 如果列类型是字符串，那一定要在条件中数据使用引号，否则不使用索引；
6. B-tree索引 is null不会走，is not null会走，位图索引 is null，is not null 都会走；
7. 组合索引遵循最左原则；


### 七、主键、外键和索引的区别
比如，A表中的一个字段，是B表的主键，就可以是A表的外键。

| 主键                    | 外键                          | 索引          |
|-----------------------|-----------------------------|-------------|
| 唯一标识一条记录，不能有重复的，不允许为空 | 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 | 该字段没有重复值，但可以有一个空值 |
| 用来保证数据完整性 | 用来和其他表建立联系用的 | 提高查询排序的速度 | 
| 主键只能有一个 | 一个表可以有多个外键 | 一个表可以有多个唯一索引 |



### 八、唯一约束和唯一索引
约束 ：全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。  
索引：数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。  
唯一约束：保证在一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一约束允许为 NULL，只是只能有一行。  
唯一索引：不允许具有索引值相同的行，从而禁止重复的索引或键值。  
唯一约束和唯一索引都是为了保证表中被限制的字段不允许有重复的值，看起来功能是一样的，那为什么要设计这样两种一样的功能呢？  
唯一约束和唯一索引在 MySQL 数据库里区别了：
概念上不同，约束是为了保证数据的完整性，索引是为了辅助查询；创建唯一约束时，会自动的创建唯一索引；在理论上，不一样，在实际使用时，基本没有区别。  
关于第二条，MySQL 中唯一约束是通过唯一索引实现的，为了保证没有重复值，在插入新记录时会再检索一遍，怎样检索快，当然是建索引了，所以，在创建唯一约束的时候就创建了唯一索引。